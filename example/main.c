#include <glsl-processor/defs.h>
#include <glsl-processor/logging.h>
#include <glsl-processor/memoryalloc.h>
#include <glsl-processor/ast.h>
#include <glsl-processor/builder.h>
#include <glsl-processor/process.h>
#include <glsl-processor/write_c_interface.h>

static const struct {
        const char *shaderID;
        const char *fileID;
        int shadertypeKind;
} shaders[] = {
#define VERT(x) { x "_vert", "example-shaders/" x ".vert", GP_SHADERTYPE_VERTEX }
#define FRAG(x) { x "_frag", "example-shaders/" x ".frag", GP_SHADERTYPE_FRAGMENT }
        VERT("line"),
        FRAG("line"),
        VERT("circle"),
        FRAG("circle"),
        VERT("arc"),
        FRAG("arc"),
#undef VERT
#undef FRAG
};

static const char *const programs[] = {
        "line",
        "circle",
        "arc",
};

static const struct {
        const char *program;
        const char *shader;
} links[] = {
        { "line", "line_vert" },
        { "line", "line_frag" },
        { "circle", "circle_vert" },
        { "circle", "circle_frag" },
        { "arc", "arc_vert" },
        { "arc", "arc_frag" },
};

int main(void)
{
        struct GP_Builder sp = {0};
        for (int i = 0; i < LENGTH(shaders); i++) {
                const char *filepath = shaders[i].fileID;
                FILE *f = fopen(filepath, "rb");
                if (f == NULL)
                        gp_fatal_f("Failed to open shader file '%s'", filepath);
                fseek(f, 0, SEEK_END);
                long size = ftell(f);
                char *data;
                ALLOC_MEMORY(&data, size + 1);
                fseek(f, 0, SEEK_SET);
                size_t nread = fread(data, 1, size + 1, f);
                if (nread != size)
                        gp_fatal_f("Expected to read %d bytes from '%s', but got %d",
                                size, filepath, nread);
                if (ferror(f))
                        gp_fatal_f("I/O error while reading from '%s'", filepath);
                fclose(f);
                gp_builder_create_file(&sp, shaders[i].fileID, data, size);
        }
        for (int i = 0; i < LENGTH(shaders); i++)
                gp_builder_create_shader(&sp, shaders[i].shaderID, shaders[i].fileID, shaders[i].shadertypeKind);
        for (int i = 0; i < LENGTH(programs); i++)
                gp_builder_create_program(&sp, programs[i]);
        for (int i = 0; i < LENGTH(links); i++)
                gp_builder_create_link(&sp, links[i].program, links[i].shader);
        gp_builder_process(&sp);
        struct GP_Ctx ctx = {0};
        gp_builder_to_ctx(&sp, &ctx);
        for (int i = 0; i < ctx.numShaders; i++)
                gp_parse_shader(&ctx, i);
        gp_process(&ctx);
        write_c_interface(&ctx, "autogenerated/");
        gp_teardown(&ctx);
        return 0;
}
