#include <glsl-processor/logging.h>
#include <glsl-processor/memoryalloc.h>
#include <glsl-processor/ast.h>
#include <stdio.h>


#ifdef _MSC_VER
#include <Windows.h>
static void make_directory_if_not_exists(const char *dirpath)
{
        BOOL ret = CreateDirectory(dirpath, NULL);
        if (!ret && GetLastError() != ERROR_ALREADY_EXISTS)
                fatal_f("Failed to create directory %s", dirpath);
}
#else
#include <sys/stat.h>
#include <sys/types.h>
#include <errno.h>
static void make_directory_if_not_exists(const char *dirpath)
{
        int r = mkdir(dirpath, 0770);
        if (r == -1)
                fatal_f("Failed to create directory %s: %s",
                        dirpath, strerror(errno));
}
#endif

// TODO
#define AUTOGENERATED_DIR "autogenerated/"
#define IFACE_C_FILEPATH AUTOGENERATED_DIR "shaders.c"
#define IFACE_H_FILEPATH AUTOGENERATED_DIR "shaders.h"

struct MtsCtx {
        struct Ast *ast;
        FILE *hFileHandle;
        FILE *cFileHandle;
};

static FILE *create_or_truncate_file_and_open_for_writing(const char *filepath)
{
        FILE *f = fopen(filepath, "wb");
        if (f == NULL)
                fatal_f("failed to open file for writing: %s", filepath);
        return f;
}

struct LinkedShaderIterator {
        struct Ast *ast;
        int programIndex;
        int linkIndex;
};

static void begin_iterating_linked_shaders(struct LinkedShaderIterator *iter, struct Ast *ast, int programIndex)
{
        iter->ast = ast;
        iter->programIndex = programIndex;
        iter->linkIndex = 0;
        while (iter->linkIndex < ast->numLinkItems && ast->linkItems[iter->linkIndex].resolvedProgramIndex != programIndex)
                iter->linkIndex++;
}

static int have_linked_shader(struct LinkedShaderIterator *iter)
{
        return iter->linkIndex < iter->ast->numLinkItems;
}

static void go_to_next_linked_shader(struct LinkedShaderIterator *iter)
{
        ENSURE(iter->linkIndex < iter->ast->numLinkItems);
        iter->linkIndex++;
        while (iter->linkIndex < iter->ast->numLinkItems && iter->ast->linkItems[iter->linkIndex].resolvedProgramIndex != iter->programIndex)
                iter->linkIndex++;
}

static int get_linked_shader(struct LinkedShaderIterator *iter)
{
        ENSURE(iter->linkIndex < iter->ast->numLinkItems);
        return iter->ast->linkItems[iter->linkIndex].resolvedShaderIndex;
}

struct UniformIterator {
        struct LinkedShaderIterator shaderIter;
        struct Ast *ast;
        struct ShaderfileAst *fa;
        int toplevelNodeIndex;
};

static int have_uniform(struct UniformIterator *iter)
{
        if (iter->fa != NULL) {
                ENSURE(iter->toplevelNodeIndex < iter->fa->numToplevelNodes);
                ENSURE(iter->fa->toplevelNodes[iter->toplevelNodeIndex]->directiveKind == DIRECTIVE_UNIFORM);
        }
        return iter->fa != NULL;
}

static void go_to_next_uniform(struct UniformIterator *iter)
{
        ENSURE(iter->fa != NULL);  // because we shouldn't be called otherwise
        ENSURE(iter->toplevelNodeIndex < iter->fa->numToplevelNodes);  // because, if iter->fa != NULL, the toplevelNodeIndex should be valid.
        iter->toplevelNodeIndex++;
        for (;;) {
                while (iter->toplevelNodeIndex < iter->fa->numToplevelNodes && iter->fa->toplevelNodes[iter->toplevelNodeIndex]->directiveKind != DIRECTIVE_UNIFORM)
                        iter->toplevelNodeIndex++;
                if (iter->toplevelNodeIndex < iter->fa->numToplevelNodes)
                        break;
                go_to_next_linked_shader(&iter->shaderIter);
                if (!have_linked_shader(&iter->shaderIter)) {
                        iter->fa = NULL;
                        break;
                }
                int shaderIndex = get_linked_shader(&iter->shaderIter);
                iter->fa = &iter->ast->shaderfileAsts[shaderIndex];
                iter->toplevelNodeIndex = 0;
        }
}

static void begin_iterating_uniforms(struct UniformIterator *iter, struct Ast *ast, int programIndex)
{
        begin_iterating_linked_shaders(&iter->shaderIter, ast, programIndex);
        iter->ast = ast;
        iter->fa = NULL;
        iter->toplevelNodeIndex = -1337;
        if (have_linked_shader(&iter->shaderIter)) {
                int shaderIndex = get_linked_shader(&iter->shaderIter);
                iter->fa = &iter->ast->shaderfileAsts[shaderIndex];
                iter->toplevelNodeIndex = 0;
                // code to find first uniform.
                // very ugly code, trying to avoid duplication. There must be a better way
                if (iter->toplevelNodeIndex == iter->fa->numToplevelNodes
                        || iter->fa->toplevelNodes[iter->toplevelNodeIndex]->directiveKind != DIRECTIVE_UNIFORM)
                        go_to_next_uniform(iter);
        }
}

static struct UniformDecl *get_uniform(struct UniformIterator *iter)
{
        ENSURE(have_uniform(iter));
        return iter->fa->toplevelNodes[iter->toplevelNodeIndex]->data.tUniform;
}



struct VariableIterator {
        struct LinkedShaderIterator shaderIter;
        struct Ast *ast;
        struct ShaderfileAst *fa;
        int toplevelNodeIndex;
};

static int have_variable(struct VariableIterator *iter)
{
        if (iter->fa != NULL) {
                ENSURE(iter->toplevelNodeIndex < iter->fa->numToplevelNodes);
                ENSURE(iter->fa->toplevelNodes[iter->toplevelNodeIndex]->directiveKind == DIRECTIVE_VARIABLE);
        }
        return iter->fa != NULL;
}

static void go_to_next_variable(struct VariableIterator *iter)
{
        ENSURE(iter->fa != NULL);  // because we shouldn't be called otherwise
        ENSURE(iter->toplevelNodeIndex < iter->fa->numToplevelNodes);  // because, if iter->fa != NULL, the toplevelNodeIndex should be valid.
        iter->toplevelNodeIndex++;
        for (;;) {
                while (iter->toplevelNodeIndex < iter->fa->numToplevelNodes && iter->fa->toplevelNodes[iter->toplevelNodeIndex]->directiveKind != DIRECTIVE_VARIABLE)
                        iter->toplevelNodeIndex++;
                if (iter->toplevelNodeIndex < iter->fa->numToplevelNodes)
                        break;
                go_to_next_linked_shader(&iter->shaderIter);
                if (!have_linked_shader(&iter->shaderIter)) {
                        iter->fa = NULL;
                        break;
                }
                int shaderIndex = get_linked_shader(&iter->shaderIter);
                iter->fa = &iter->ast->shaderfileAsts[shaderIndex];
                iter->toplevelNodeIndex = 0;
        }
}

static void begin_iterating_variables(struct VariableIterator *iter, struct Ast *ast, int programIndex)
{
        begin_iterating_linked_shaders(&iter->shaderIter, ast, programIndex);
        iter->ast = ast;
        iter->fa = NULL;
        iter->toplevelNodeIndex = -1337;
        if (have_linked_shader(&iter->shaderIter)) {
                int shaderIndex = get_linked_shader(&iter->shaderIter);
                iter->fa = &iter->ast->shaderfileAsts[shaderIndex];
                iter->toplevelNodeIndex = 0;
                // code to find first uniform.
                // very ugly code, trying to avoid duplication. There must be a better way
                if (iter->toplevelNodeIndex == iter->fa->numToplevelNodes
                        || iter->fa->toplevelNodes[iter->toplevelNodeIndex]->directiveKind != DIRECTIVE_VARIABLE)
                        go_to_next_variable(iter);
        }
}

static struct VariableDecl *get_variable(struct VariableIterator *iter)
{
        ENSURE(have_variable(iter));
        return iter->fa->toplevelNodes[iter->toplevelNodeIndex]->data.tVariable;
}



void begin_enum(struct MtsCtx *ctx)
{
        fprintf(ctx->hFileHandle, "enum {\n");
}

void end_enum(struct MtsCtx *ctx)
{
        fprintf(ctx->hFileHandle, "};\n");
}

void add_enum_item(struct MtsCtx *ctx, const char *name1)
{
        fprintf(ctx->hFileHandle, "        %s,\n", name1);
}

void add_enum_item_2(struct MtsCtx *ctx, const char *name1, const char *name2)
{
        fprintf(ctx->hFileHandle, "        %s_%s,\n", name1, name2);
}

void add_enum_item_3(struct MtsCtx *ctx, const char *name1, const char *name2, const char *name3)
{
        fprintf(ctx->hFileHandle, "        %s_%s_%s,\n", name1, name2, name3);
}

void add_enum_item_AstString(struct MtsCtx *ctx, const char *enumPrefix, AstString astString)
{
        add_enum_item_2(ctx, enumPrefix, get_aststring_buffer(ctx->ast, astString));
}

void process_mts(struct Ast *ast)
{
        make_directory_if_not_exists(AUTOGENERATED_DIR);
        struct MtsCtx mtsCtx = { 0 };
        struct MtsCtx *ctx = &mtsCtx;
        ctx->ast = ast;
        ctx->cFileHandle = create_or_truncate_file_and_open_for_writing(IFACE_C_FILEPATH);
        ctx->hFileHandle = create_or_truncate_file_and_open_for_writing(IFACE_H_FILEPATH);

        fprintf(ctx->hFileHandle, "%s",
                "enum {\n"
                "        PRIMTYPE_FLOAT,\n"
                "        PRIMTYPE_VEC2,\n"
                "        PRIMTYPE_VEC3,\n"
                "        PRIMTYPE_VEC4,\n"
                "        PRIMTYPE_MAT2,\n"
                "        PRIMTYPE_MAT3,\n"
                "        PRIMTYPE_MAT4,\n"
                "};\n"
                );

        begin_enum(ctx);
        for (int i = 0; i < ast->numPrograms; i++)
                add_enum_item_AstString(ctx, "PROGRAM", ast->programDecls[i].programName);
        add_enum_item(ctx, "NUM_PROGRAM_KINDS");
        end_enum(ctx);

        begin_enum(ctx);
        for (int i = 0; i < ast->numShaders; i++)
                add_enum_item_AstString(ctx, "SHADER", ast->shaderDecls[i].shaderName);
        add_enum_item(ctx, "NUM_SHADER_KINDS");
        end_enum(ctx);

        //XXX: too much code here
        begin_enum(ctx);
        for (int programIndex = 0; programIndex < ast->numPrograms; programIndex++) {
                const char *programName = get_aststring_buffer(ast, ast->programDecls[programIndex].programName);
                struct UniformIterator uniformIter;
                for (begin_iterating_uniforms(&uniformIter, ast, programIndex);
                        have_uniform(&uniformIter); go_to_next_uniform(&uniformIter))
                {
                        struct UniformDecl *decl = get_uniform(&uniformIter);
                        const char *uniformName = get_aststring_buffer(ast, decl->uniDeclName);
                        add_enum_item_3(ctx, "UNIFORM", programName, uniformName);
                }
        }
        add_enum_item(ctx, "NUM_UNIFORM_KINDS");
        end_enum(ctx);

        //XXX: too much code here
        begin_enum(ctx);
        for (int programIndex = 0; programIndex < ast->numPrograms; programIndex++) {
                const char *programName = get_aststring_buffer(ast, ast->programDecls[programIndex].programName);
                struct VariableIterator variableIter;
                for (begin_iterating_variables(&variableIter, ast, programIndex);
                        have_variable(&variableIter); go_to_next_variable(&variableIter))
                {
                        struct VariableDecl *decl = get_variable(&variableIter);
                        if (decl->inOrOut != 0) /* TODO: enum for this. 0 == IN direction */
                                continue;
                        { // this code is too complex. It should be easier to determine the shader type.
                                int shaderIndex = ast->linkItems[variableIter.shaderIter.linkIndex].resolvedShaderIndex;
                                int shaderType = ast->shaderDecls[shaderIndex].shaderType;
                                if (shaderType != SHADERTYPE_VERTEX)
                                        continue;  // only vertex shaders can contain attributes. Attributes are "in" variables of the vertex shader.
                        }
                        const char *attribName = get_aststring_buffer(ast, decl->name);
                        add_enum_item_3(ctx, "ATTRIBUTE", programName, attribName);
                }
        }
        add_enum_item(ctx, "NUM_ATTRIBUTE_KINDS");
        end_enum(ctx);

        fprintf(ctx->hFileHandle,
                "#include <GLshadermanager/GLshadermanager.h>\n"
                "extern const struct SM_ShaderInfo smShaderInfo[NUM_SHADER_KINDS];\n"
                "extern const struct SM_ProgramInfo smProgramInfo[NUM_PROGRAM_KINDS];\n"
                "extern const struct SM_LinkInfo smLinkInfo[];\n"
                "extern const int numLinkInfos;\n"
                "extern const struct SM_UniformInfo smUniformInfo[NUM_UNIFORM_KINDS];\n"
                "extern const struct SM_AttributeInfo smAttributeInfo[NUM_ATTRIBUTE_KINDS];\n"
                "extern const struct SM_Description smDescription;\n"
        );

        fprintf(ctx->cFileHandle, "#include <%s>\n", IFACE_H_FILEPATH);

        fprintf(ctx->cFileHandle, "const struct SM_ProgramInfo smProgramInfo[NUM_PROGRAM_KINDS] = {\n");
        for (int i = 0; i < ast->numPrograms; i++) {
                const char *programName = get_aststring_buffer(ast, ast->programDecls[i].programName);
                fprintf(ctx->cFileHandle, "        [PROGRAM_%s] = \"PROGRAM_%s\",\n", programName, programName);
        }
        fprintf(ctx->cFileHandle, "};\n");

        fprintf(ctx->cFileHandle, "const struct SM_ShaderInfo smShaderInfo[NUM_SHADER_KINDS] = {\n");
        for (int i = 0; i < ast->numShaders; i++) {
                struct ShaderDecl *decl = &ast->shaderDecls[i];
                const char *shaderName = get_aststring_buffer(ast, decl->shaderName);
                int shaderTypeKind = decl->shaderType;
                fprintf(ctx->cFileHandle, "        [SHADER_%s] = { %s, \"SHADER_%s\", \"TODO: shader source?\" },\n", shaderName, shadertypeKindString[shaderTypeKind], shaderName);
        }
        fprintf(ctx->cFileHandle, "};\n");
        
        fprintf(ctx->cFileHandle, "const struct SM_LinkInfo smLinkInfo[] = {\n");
        for (int i = 0; i < ast->numLinkItems; i++) {
                //int programIndex = ast->linkItems[i].resolvedProgramIndex;
                //int shaderIndex = ast->linkItems[i].resolvedShaderIndex;
                const char *programName = get_aststring_buffer(ast, ast->linkItems[i].programName);
                const char *shaderName = get_aststring_buffer(ast, ast->linkItems[i].shaderName);
                fprintf(ctx->cFileHandle, "        { PROGRAM_%s, SHADER_%s },\n", programName, shaderName);
        }
        fprintf(ctx->cFileHandle, "};\n");

        fprintf(ctx->cFileHandle, "const struct SM_UniformInfo smUniformInfo[NUM_UNIFORM_KINDS] = {\n");
        for (int programIndex = 0; programIndex < ast->numPrograms; programIndex++) {
                const char *programName = get_aststring_buffer(ast, ast->programDecls[programIndex].programName);
                struct UniformIterator uniformIter;
                for (begin_iterating_uniforms(&uniformIter, ast, programIndex);
                        have_uniform(&uniformIter); go_to_next_uniform(&uniformIter))
                {
                        struct UniformDecl *decl = get_uniform(&uniformIter);
                        const char *uniformName = get_aststring_buffer(ast, decl->uniDeclName);
                        int typeKind = decl->uniDeclTypeExpr->primtypeKind;  //XXX depending on complicated data structure and bad design. There are no "type exprs"
                        const char *typeName = primtypeKindString[typeKind];
                        fprintf(ctx->cFileHandle, "        [UNIFORM_%s_%s] = { PROGRAM_%s, %s, \"%s\", \"UNIFORM_%s_%s\" },\n",
                                programName, uniformName, programName, typeName, uniformName, programName, uniformName);
                }
        }
        fprintf(ctx->cFileHandle, "};\n");

        fprintf(ctx->cFileHandle, "const struct SM_AttributeInfo smAttributeInfo[NUM_ATTRIBUTE_KINDS] = {\n");
        for (int programIndex = 0; programIndex < ast->numPrograms; programIndex++) {
                const char *programName = get_aststring_buffer(ast, ast->programDecls[programIndex].programName);
                struct VariableIterator variableIter;
                for (begin_iterating_variables(&variableIter, ast, programIndex);
                        have_variable(&variableIter); go_to_next_variable(&variableIter))
                {
                        struct VariableDecl *decl = get_variable(&variableIter);
                        if (decl->inOrOut != 0) /* TODO: enum for this. 0 == IN direction */
                                continue;
                        { // this code is too complex. It should be easier to determine the shader type.
                                int shaderIndex = ast->linkItems[variableIter.shaderIter.linkIndex].resolvedShaderIndex;
                                int shaderType = ast->shaderDecls[shaderIndex].shaderType;
                                if (shaderType != SHADERTYPE_VERTEX)
                                        continue;  // only vertex shaders can contain attributes. Attributes are "in" variables of the vertex shader.
                        }
                        const char *attribName = get_aststring_buffer(ast, decl->name);
                        int primtypeKind = decl->typeExpr->primtypeKind;
                        const char *typeName = primtypeKindString[primtypeKind];
                        fprintf(ctx->cFileHandle, "        [ATTRIBUTE_%s_%s] = { PROGRAM_%s, %s, \"%s\", \"ATTRIBUTE_%s_%s\" },\n",
                                programName, attribName, programName, typeName, attribName, programName, attribName);
                }
        }
        fprintf(ctx->cFileHandle, "};\n");

        fprintf(ctx->cFileHandle,
                "const struct SM_Description smDescription = {\n"
                "        .programInfo = smProgramInfo,\n"
                "        .shaderInfo = smShaderInfo,\n"
                "        .linkInfo = smLinkInfo,\n"
                "        .uniformInfo = smUniformInfo,\n"
                "        .attributeInfo = smAttributeInfo,\n"
                "};\n"
        );

        for (int programIndex = 0; programIndex < ast->numPrograms; programIndex++) {
                const char *programName = get_aststring_buffer(ast, ast->programDecls[programIndex].programName);
                struct UniformIterator uniformIter;
                for (begin_iterating_uniforms(&uniformIter, ast, programIndex);
                        have_uniform(&uniformIter); go_to_next_uniform(&uniformIter))
                {
                        struct UniformDecl *decl = get_uniform(&uniformIter);
                        const char *uniformName = get_aststring_buffer(ast, decl->uniDeclName);
                        int typeKind = decl->uniDeclTypeExpr->primtypeKind;  //XXX depending on complicated data structure and bad design. There are no "type exprs"
                        fprintf(ctx->hFileHandle, "static inline void set_uniform_%s_%s", programName, uniformName);
                        const char *fmt;
                        switch (typeKind) {
                        case PRIMTYPE_FLOAT: fmt = "(float x) { set_GfxProgram_uniform_1f(programID[PROGRAM_%s], uniformLocation[UNIFORM_%s_%s], x); }\n"; break;
                        case PRIMTYPE_VEC2: fmt = "(float x, float y) { set_GfxProgram_uniform_2f(programID[PROGRAM_%s], uniformLocation[UNIFORM_%s_%s], x, y); }\n"; break;
                        case PRIMTYPE_VEC3: fmt = "(float x, float y, float z) { set_GfxProgram_uniform_3f(programID[PROGRAM_%s], uniformLocation[UNIFORM_%s_%s], x, y, z); }\n"; break;
                        case PRIMTYPE_VEC4: fmt = "(float x, float y, float z, float w) { set_GfxProgram_uniform_4f(programID[PROGRAM_%s], uniformLocation[UNIFORM_%s_%s], x, y, z, w); }\n"; break;
                        case PRIMTYPE_MAT2: fmt = "(float *fourFloats) { set_GfxProgram_uniform_mat2f(programID[PROGRAM_%s], uniformLocation[UNIFORM_%s_%s], fourFloats); }\n"; break;
                        case PRIMTYPE_MAT3: fmt = "(float *nineFloats) { set_GfxProgram_uniform_mat3f(programID[PROGRAM_%s], uniformLocation[UNIFORM_%s_%s], nineFloats); }\n"; break;
                        case PRIMTYPE_MAT4: fmt = "(float *sixteenFloats) { set_GfxProgram_uniform_mat4f(programID[PROGRAM_%s], uniformLocation[UNIFORM_%s_%s], sixteenFloats); }\n"; break;
                        default: fatal_f("Not implemented!");
                        }
                        fprintf(ctx->hFileHandle, fmt, programName, programName, uniformName);
                }
        }

        /* TODO: AttribVertexPointers using structs that contain all the attributes (full AOS). */

        fclose(ctx->cFileHandle);
        fclose(ctx->hFileHandle);
}
